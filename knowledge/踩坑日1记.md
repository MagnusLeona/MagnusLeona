

### 踩坑日记



> ##### 记一次Redis远端无法连接的问题解决方式。
>
> > 2022/03/21
> >
> > 问题：某次在远端Linux服务器上下载了redis包，按照正常情况，解压缩，make编译，修改了配置文件中如下：
> >
> > ```properties
> > bind 0.0.0.0
> > protected-mode no
> > daemonize yes
> > ```
> >
> > 使用此配置文件启动redis-server，第一次通过自己的电脑（客户端）连接远端：
> >
> > ```bash
> > redis-cli -h host -p port
> > ```
> >
> > 然后连接成功，执行PING命令能正确返回。
> >
> > 可是，奇怪的问题就发生了。再次通过Redis-CLI去连接Server的时候，就开始报错超时了。一开始以为是redis服务挂了，可是在服务器本机上连接`127.0.0.1`是完全没有问题的，说明redis本身服务是没有挂掉的。难道是防火墙的问题？然后就检查了防火墙：
> >
> > ```bash
> > systemctl status firewalld.service
> > ```
> >
> > 得到的结果是，防火墙已经被关闭了。然后又检查了云服务器本身对防火墙的校验，端口也是在白名单列表的。
> >
> > 结果：
> >
> > 最后的解决方法是，检查了当前服务器的iptables：
> >
> > ```bash
> > iptables -L -n
> > ```
> >
> > 结果如下：
> >
> > ```bash
> > Chain INPUT (policy ACCEPT)
> > target     prot opt source               destination
> > ACCEPT     tcp  --  127.0.0.1            0.0.0.0/0            tcp dpt:6379
> > DROP       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:6379
> > 
> > Chain FORWARD (policy ACCEPT)
> > target     prot opt source               destination
> > 
> > Chain OUTPUT (policy ACCEPT)
> > target     prot opt source               destination
> > [root@VM-16-12-centos redis]# iptables -F
> > [root@VM-16-12-centos redis]# iptables -L -n
> > Chain INPUT (policy ACCEPT)
> > target     prot opt source               destination
> > 
> > Chain FORWARD (policy ACCEPT)
> > target     prot opt source               destination
> > 
> > Chain OUTPUT (policy ACCEPT)
> > target     prot opt source               destination
> > ```
> >
> > 根因就在与，iptables中拒绝了除`127.0.0.1`以外的所有IP对6379端口的访问。
> >
> > 所以，通过清除iptables中的访问策略，成功解决此问题：
> >
> > ```bash
> > iptables -F
> > ```
> >
> > 再次查看iptables，结果如下：
> >
> > ```bash
> > Chain INPUT (policy ACCEPT)
> > target     prot opt source               destination
> > 
> > Chain FORWARD (policy ACCEPT)
> > target     prot opt source               destination
> > 
> > Chain OUTPUT (policy ACCEPT)
> > target     prot opt source               destination
> > ```
> >
> > 此时，已经不存在过滤了，客户端正确访问。
> >
> > TODO: 需要仔细研究一下Linux的防火墙和IP tables的关系。



> ##### 记一次Redis字段找不到导致删除失败的问题排查
>
> > 问题：在做需求-定时任务删除挂起的订单的时候，在调试Redis的时候，存入了Redis的zset中的字段，在通过zrem删除这个字段的时候，每次都删除失败了。
> >
> > 分析：分析问题的时候，写了个测试类
> >
> > ```java
> > @SpringBootTest
> > class DemoApplicationTests {
> > 
> >     @Autowired
> >     RedisTemplate<String, String> redisTemplate;
> > 
> >     @Test
> >     void contextLoads() {
> >         redisTemplate.opsForZSet().add("ac", 123, 123);
> >         Set<String> orderToBeWaiting = redisTemplate.opsForZSet().range("ac", 0, 10);
> >         redisTemplate.opsForZSet().remove("ac", 123);
> >         Set<String> result = redisTemplate.opsForZSet().range("ac", 0, -1);
> >         orderToBeWaiting.forEach(System.out::println);
> >         result.forEach(System.out::println);
> >     }
> > }
> > ```
> >
> > 执行了add方法添加数据后，去Redis中查看，这个字段确实被存进去了，也确实就是存在`ac`的这个zset下。手动在Redis Cli中执行zrem方法，也是完全没问题。为什么在Spring中通过redisTemplate操作就会失败呢？
> >
> > 这时候意识到，很可能是操作到Redis的实际命令有问题。于是查询到可以在Redis Cli中通过monitor命令去监测server执行的每一个命令。
> >
> > ```bash
> > monitor
> > ```
> >
> > 然后重新执行test，结果如下：
> >
> > ```bash
> > 1647851852.827999 [0 127.0.0.1:49620] "PING"
> > 1647851953.180293 [0 127.0.0.1:49634] "ZADD" "ac" "123.0" "123"
> > 1647851953.185358 [0 127.0.0.1:49634] "ZRANGE" "ac" "0" "10"
> > 1647851953.187819 [0 127.0.0.1:49634] "ZREM" "ac" "\123\"
> > 1647851953.189070 [0 127.0.0.1:49634] "ZRANGE" "ac" "0" "-1"
> > ```
> >
> > 通过监测实际命令，发现是在zrem的时候，我们上送的字段不对，本来需要删除的是`123`，但是实际redis收到的命令是`\123\`。很显然，这是redis的serializer序列化器出现了问题。检查redis的配置项，发现我们使用的Key Serializer是`StringRedisSerializer`，而使用的Value Serializer是`GenericJackson2JsonRedisSerializer`。Debug发现，redisTemplate的remove命令第二个参数是使用的Value Serializer，也就是`GenericJackson2JsonRedisSerializer`，这个序列化器在转义String的时候出现了问题，会给字符串加上前后的字符。
> >
> > 解决：把Value Serializer替换为`StringRedisSerializer`之后问题解决。
> >
> > 后记：spring中的redisTemplate提供了很多序列化器，用的最多的就是`StringRedisSerializer`，也比较推荐这个。所以，redis操作尽量规约为String类型的key和value，避免出现太多序列化的问题。当然也可以自定义序列化器。



> Mysql数据库中关于连表查询的小tip：
>
> > 在一次开发中，遇到一个关于连表查询的问题：在使用连表查询的时候，连表的条件和查询的where条件都加上了主键，但是去分析执行计划的时候，总是用不到索引。
> >
> > 原因分析：数据库在编译SQL的时候，会先尝试优化SQL，如果表中的数据量过小，可能不会走索引。我第一次explain查看执行计划的时候，表中仅有一条数据，数据库查询发现不走索引可能更快，就不会使用索引了。当我插入了1w条数据后，果然就成功走索引了。
> >
> > ```sql
> > explain select workey_mission.* from workey_mission join workey_user_mission on workey_mission.id=workey_user_mission.mission_id where workey_user_mission.user_id=1;
> > ```
> >
> > | id   | select_type | table | partition | type   | possible_keys      | key     | key_len | ref                  | rows | filtered | extra       |
> > | ---- | ----------- | ----- | --------- | ------ | ------------------ | ------- | ------- | -------------------- | ---- | -------- | ----------- |
> > | 1    | SIMPLE      | wum   | null      | ref    | user_id,mission_id | user_id | 5       | const                | 5078 | 100.00   | Using where |
> > | 1    | SIMPLE      | wm    | null      | eq_ref | PRIMARY            | PRIMARY | 4       | wokey.wum.mission_id | 1    | 100.00   | Using index |
> >
> > 
